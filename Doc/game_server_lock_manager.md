# 게임 서버 락 매니저

## 개요

shared state multithreading을 사용해야 하는 게임들이 가끔 있다.
공성전과 같이 동시성을 최대로 올려서 처리를 해야 하는 기능이 게임의 핵심 기능인 게임들이 그렇다.

이런 경우 락을 사용할 수 밖에 없는데 데드락이 발생할 수 있고 발생하면 찾기가 상당히 까다로울 수 있다.
라이브 디버깅 환경이나 postmortem 디버깅 환경이 잘 갖춰져 있더라도 어려움은 있다.

## 접근 방법

### 필요한 락을 미리 잡고 풀기
컨텐츠 별로 분리하고 미리 실행하는 실행기에서 필요한 락을 잡고 처리하는 방법이 있다.
이 클래스를 Runner라고 하고 Runner는 Task를 실행하는 개념으로 진행한다.
GuildRunner라고 하면 Guild의 락과 해당 사용자의 락을 잡고 처리하고 풀어주는 방식이다.
Task는 처리에 진입하는 함수로 할 수 있다.

이와 같이 하려면 Update나 Tick과 같은 처리가 없어야 하고 미리 잘 설계하고
전체 구조를 모든 프로그래머가 쉽게 사용할 수 있을 정도로 정리되고 전파되어야 한다.

### 락의 순서 제어
뭔가 처리를 할 때 락을 잡기는 하지만 항상 순서대로만 잡는 것이다.
lock(self),
lock(usermanager),
lock(guild),
lock(guildmanager)

코드

unlock(guildmanager)
unlock(guild)
unlock(usermanager)
unlock(self)

위를 좀 더 쉽게 구현할 수 있어야 하는데 항상 락을 다 잡고 진행할 필요는 없으므로
lock(self) escalate(usermanager), escalate(guild), escalate(guildmanager)와 같은 식으로
하나의 락에서 시작하고 필요할 떄 락 레벨을 올리는 것으로 진행할 수 있다.

이를 LockManager 클래스와 함께 동작하도록 하고 Locker와 같은 클래스로 시작, 락 상승이 이루어지도록 하면 편하게
코딩하면서 데드락이 없게 할 수 있다. lock(grid)와 같이 일정 범위 내의 사용자들 처리에 대한 락을 잡을 수도 있다.

순서가 잘못될 경우 로그나 경고를 보여주는 방식으로 잠재적인 문제를 해결 할 수 있다.

### 정리

두 가지 방향 모두 장단점이 있다. 락 관리기는 RDMBS에서 잘 정의된 기능을 갖고 있는데 DBMS의 락 관리기는
데드락 탐지 시 트랜잭션을 포기하고 다시 시작하는 방식이고 락 순서에 관한 정리는 없다.
그래도 참고할 만할 것이다.
